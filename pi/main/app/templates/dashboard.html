{% extends "base.html" %}
{% block title %}Temperature & Humidity Chart{% endblock %}

{% block content %}

<!-- Dropdown chọn loại dữ liệu -->
<h2>Data Chart</h2>

<!-- Menu chọn loại dữ liệu -->
<div style="margin-bottom: 10px;">
  <label for="dataType">Select Data Type:</label>
  <select id="dataType">
    <option value="heart_rate">Heartrate (bpm)</option>
    <option value="spo2">spO2 (%)</option>
  </select>

  <label for="limit" style="margin-left: 20px;">Number of values:</label>
  <select id="limit">
    <option value="10">10</option>
    <option value="20">20</option>
    <option value="50">50</option>
    <option value="100">100</option>
  </select>

</div>

<!-- Khung chứa biểu đồ -->
<div class="box" style="width: 90%; max-width: 900px; height: 90%; max-height: 900px;">
  <canvas id="myChart"></canvas>
</div>



<!-- Nạp Chart.js -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
  const building = "{{building}}";
  const floor = "{{floor}}";
  const room = "{{room}}";

  const ctx = document.getElementById('myChart').getContext('2d');
  let chart; // để lưu biểu đồ và cập nhật sau

  async function fetchAndDraw(selectedType) {
    const limit = document.getElementById('limit').value || 50;
    const res = await fetch(`/api/get_data?building=${building}&floor=${floor}&room=${room}&type=${selectedType}&limit=${limit}`);
    const d = await res.json();

    // ✅ Thêm log để kiểm tra dữ liệu trả về
    console.log("Dữ liệu nhận từ server:", d);

    // Nếu đã có biểu đồ, xóa trước khi vẽ mới
    if (chart) {
      chart.destroy();
    }

    // Ép chuỗi sang số
    const values = d[selectedType].map(v => parseFloat(v));

    console.log("Giá trị sau khi ép số:", values);

    // "...": chuyển 1 mảng thành các phần tử rời để Math.min .max hiểu được
    // thêm padding để biểu đồ có kích thước vừa phải
    let padding = Math.max(...values) - Math.min(...values)
    // thêm padding mặc định khi min==max
    if (padding === 0) {
      padding = 1; 
    }
    let minY = Math.min(...values) - padding; 
    let maxY = Math.max(...values) + padding;



    console.log("Dataset gửi vào Chart.js:", {
      labels: d.labels,
      data: values
    });


    chart = new Chart(ctx, {
      type: 'line',
      data: {
        labels: d.labels,
        datasets: [{
          label: selectedType,
          data: values,
          borderColor: 'rgba(54, 162, 235, 1)',
          backgroundColor: 'rgba(54, 162, 235, 0.2)',
          borderWidth: 2,
          fill: false,
          tension: 0.1
        }]
      },
      options: {
        // responsive: true,
        // maintainAspectRatio: false, // cho phép canvas cao hơn khi rộng hơn
        scales: {
          y: {
            min: minY,
            max: maxY
          }
        }
      }
    });
    console.log("Chart đã được tạo:", chart);
  }

  // Lấy loại dữ liệu đầu tiên khi tải trang
  const select = document.getElementById('dataType');
  fetchAndDraw(select.value);

  // Khi thay đổi lựa chọn -> vẽ biểu đồ mới
  select.addEventListener('change', () => {
    fetchAndDraw(select.value);
  });

  // Khi thay đổi số lượng data -> vẽ lại
  document.getElementById('limit').addEventListener('change', () => {
    fetchAndDraw(select.value);
  });
</script>


{% endblock %}
